

<!DOCTYPE html>
<html lang="en">
<head>
  


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>从字典树到AC自动机 [ ooxoio blog ]</title>

  <link rel="icon" href="/img/icon.png">


    <meta name="author" content="ooxoio">





  <link rel="alternate" href="/atom.xml " title="ooxoio blog" type="application/atom+xml">


  
    <link rel="stylesheet" href="/css/main.css">
  

<meta name="generator" content="Hexo 5.4.0"></head>
  <body data-theme="light" class="notransition">
    <script>
      const body = document.body;
      const data = body.getAttribute("data-theme");
      const initTheme = (state) => {
        if (state === "dark") {
          body.setAttribute("data-theme", "dark");
        } else if (state === "light") {
          body.removeAttribute("data-theme");
        } else {
          localStorage.setItem("theme", data);
        }
      };
   
      initTheme(localStorage.getItem("theme"));
      
      setTimeout(() => body.classList.remove("notransition"), 75);
    </script>
  <div class="navbar" role="navigation">
    <nav class="menu">
      <input type="checkbox" id="menu-trigger" class="menu-trigger" />
      <label for="menu-trigger">
        <span class="menu-icon">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 512 512"
          >
            <path
              d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"
            />
          </svg>
        </span>
      </label>
      <a id="mode">
        <svg
          class="mode-sunny"
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 512 512"
        >
          <title>LIGHT</title>
          <line
            x1="256"
            y1="48"
            x2="256"
            y2="96"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="256"
            y1="416"
            x2="256"
            y2="464"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="403.08"
            y1="108.92"
            x2="369.14"
            y2="142.86"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="142.86"
            y1="369.14"
            x2="108.92"
            y2="403.08"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="464"
            y1="256"
            x2="416"
            y2="256"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="96"
            y1="256"
            x2="48"
            y2="256"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="403.08"
            y1="403.08"
            x2="369.14"
            y2="369.14"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="142.86"
            y1="142.86"
            x2="108.92"
            y2="108.92"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <circle
            cx="256"
            cy="256"
            r="80"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
        </svg>
        <svg
          class="mode-moon"
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 512 512"
        >
          <title>DARK</title>
          <line
            x1="256"
            y1="48"
            x2="256"
            y2="96"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="256"
            y1="416"
            x2="256"
            y2="464"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="403.08"
            y1="108.92"
            x2="369.14"
            y2="142.86"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="142.86"
            y1="369.14"
            x2="108.92"
            y2="403.08"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="464"
            y1="256"
            x2="416"
            y2="256"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="96"
            y1="256"
            x2="48"
            y2="256"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="403.08"
            y1="403.08"
            x2="369.14"
            y2="369.14"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <line
            x1="142.86"
            y1="142.86"
            x2="108.92"
            y2="108.92"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
          <circle
            cx="256"
            cy="256"
            r="80"
            style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"
          />
        </svg>
      </a>
      <div class="trigger">
        <div class="trigger-container">
          
            
            
            
            
            
            
            <a class="menu-link " href="/"> Home</a>
          
            
            
            
            
            
            
            <a class="menu-link " href="/archives/"> Archives</a>
          
            
            
            
            
            
            
            <a class="menu-link " href="/about/"> About</a>
          
            
            
            
            
            
            
            <a class="menu-link " href="/tags/"> Tags</a>
          
        </div>
      </div>
    </nav>
  </div>
  
<div class="wrapper post">
  <main class="page-content" aria-label="Content">
      <header class="header">
        
          <div class="tags">
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="tag"># 数据结构</a>
          </div>
        
        <h1 class="header-title" itemprop="headline">从字典树到AC自动机</h1>
          <div class="post-meta">
            <time>Oct 21, 2021</time>
            <span itemprop="author">
              <span itemprop="name">ooxoio</span>
            </span>
          </div>
        </header>

          <div class="page-content"><p><strong>数据结构：记录常见的数据结构。</strong></p>
<hr>
<h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><p>1.相同的前缀只会在树上保存一个结点，不会重复，因此又称前缀树。</p>
<p>2.适用于在多个字符串中判断某个字符串是否存在。</p>
<h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node *next[<span class="number">26</span>]; <span class="comment">// 假设场景是26个小写字母，那么每个结点下就是有26个Node*。</span></span><br><span class="line">    <span class="keyword">int</span> flag;		<span class="comment">// 标志该节点是不是某个字符串的末尾</span></span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="built_in">memeset</span>(<span class="keyword">this</span>-&gt;next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">this</span>-&gt;next)); <span class="comment">// 初始化置空。</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>插入某个字符串到字典树中。</span><br><span class="line">    <span class="built_in">insert</span>(string s);</span><br><span class="line">时间复杂度<span class="built_in">O</span>(N)。</span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span>判断字符串s是否存在在字典树中。</span><br><span class="line">    <span class="built_in">search</span>(string s);</span><br><span class="line">时间复杂度<span class="built_in">O</span>(N)。</span><br></pre></td></tr></table></figure>

<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        Node *next[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="built_in">Node</span>() &#123;</span><br><span class="line">            <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(next));</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ind = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;next[ind]) &#123;</span><br><span class="line">                p-&gt;next[ind] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next[ind];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ind = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;next[ind]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;next[ind];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="题目练习："><a href="#题目练习：" class="headerlink" title="题目练习："></a>题目练习：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模板题：LC<span class="number">.208</span></span><br><span class="line">练习题：LC<span class="number">.211</span></span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>字典树的模型很好记住，能用到的场景也比较好联想到。特点就是利用前缀只保存一份来优化。</p>
<h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><p>仍然给你字符串s，但要你判断该字符串有多少子串出现在字典树中。即组成字典树的字符串有哪些是s的子串。</p>
<p>上述字典树中search的参数s是固定的，字典树是多个字符串，1对多的关系。现在问题就转为多对多的关系。</p>
<p>引入AC自动机。</p>
<hr>
<h3 id="AC自动机："><a href="#AC自动机：" class="headerlink" title="AC自动机："></a>AC自动机：</h3><p>1.目的：希望在多模匹配的时候，待匹配串s可以只遍历一遍，不断在字典树上跳来跳去来得到所有答案。</p>
<p>2.关键：建立等价关系，即每个结点多一个fail指针。</p>
<p>作用：当目前这个前缀继续往后匹配不到s[i]的时候，指针应该跳到哪个结点，既可以不错过答案，又可以节省不必要的比较。</p>
<p>思想：当前结点p无法匹配s的下一个字符s[i]的时候，转到当前结点的等价关系(假设为k)下去查找是否存在s[i]。p和k有个公共特点就是它们拥有一样的后缀。可以画个例子模拟一下会好理解一些。</p>
<p>等价关系结点怎么找：假设当前结点p代表next[0]，则该结点的等价关系等于p的父节点的fail指针所指的结点(设为f)的,f-&gt;next[0]。如果此时f-&gt;next[0]也没有，那就再移动到f的fail指针，以此类推直到root结点。root结点的fail指针是nullptr，用来标志找不到。</p>
<p>第一层的所有结点的fail指针都是root。</p>
<p>由于越靠下的结点等价关系依赖于上层的结点，因此可以使用层次遍历的顺序来构建每个结点的fail指针。</p>
<p>具体做法就是：</p>
<p>先把第一层的结点入队，因为它们的等价关系都是root。</p>
<p>每次取一个结点，去初始化它的所有子结点的等价关系，因为入队的结点fail指针已经求出来了，而子结点依赖于父节点的fail，自然可以求。</p>
<p><strong>正确性：</strong></p>
<p>因为每次fail指针不断往上移，所以前缀是不断在缩小，可以理解为就是在判断子串是否有满足的。如果一直移动到root还没有，就说明构造这棵字典树的所有模式串里就没有以当前字母s[i]开头的子串，此时p回到了root，s[i]之前的所有子串都不存在答案，继续匹配即可。</p>
<p>如果不理解，可以简单画个样例就明白了。</p>
<p><strong>注意：</strong>当匹配到s[i]的时候，仍需要遍历当前结点p的所有fail指针判断flag是不是1，否则会漏掉答案。例如：待匹配串s = abcdehr,模式串有 r、hr。当s遍历到末尾的时候，hr匹配到了，如果此时不遍历r的fail指针，就会漏掉r这个答案。</p>
<p>3.时间复杂度：</p>
<p>首先是构建字典树，方法和普通字典树一样，都是O(N*k)，K代表模式串的数量。</p>
<p>然后是在字典树的基础上构建AC自动机，即初始化fail指针。需要层次遍历每个结点，复杂度最多就是所有结点的个数。</p>
<p>然后就是最初的目的从待匹配串s中找匹配的模式串。只需要正常遍历s串即可，时间复杂度O(N)。</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node *next[<span class="number">26</span>];</span><br><span class="line">    Node *fail;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">Node</span> () &#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(next));</span><br><span class="line">        fail = <span class="literal">nullptr</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node *root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;next[ind]) &#123;</span><br><span class="line">            p-&gt;next[ind] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    p-&gt;s = s;</span><br><span class="line">    cout &lt;&lt; p-&gt;s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_AC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    root-&gt;fail = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(root-&gt;next[i]);</span><br><span class="line">            root-&gt;next[i]-&gt;fail = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;next[i]) <span class="keyword">continue</span>;</span><br><span class="line">            Node *p = t-&gt;fail;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;next[i]) &#123;</span><br><span class="line">                    t-&gt;next[i]-&gt;fail = p-&gt;next[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">                t-&gt;next[i]-&gt;fail = root;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;build end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; p-&gt;next[ind] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="comment">// 这里别搞错了，记得下移</span></span><br><span class="line">            Node *t = p-&gt;next[ind];</span><br><span class="line">            p = p-&gt;next[ind];</span><br><span class="line">            <span class="keyword">while</span> (t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;flag) &#123;</span><br><span class="line">                    cout &lt;&lt; t-&gt;s &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                t = t-&gt;fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_AC</span>();</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">match</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span>：</span><br><span class="line">say</span><br><span class="line">she</span><br><span class="line">shr</span><br><span class="line">he</span><br><span class="line">her</span><br><span class="line">sasherhs</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">she </span><br><span class="line">he</span><br><span class="line">her</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h3 id="AC自动机优化："><a href="#AC自动机优化：" class="headerlink" title="AC自动机优化："></a>AC自动机优化：</h3><p>上述代码中，match函数中找等价关系的时候这个while循环，耗费了大量的时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match函数中：</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next[ind] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       p = p-&gt;fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考一下：</p>
<p>这一步找等价关系，是因为我们在当前结点下找不到next[ind]，因此需要去等价关系下寻找。如果当前结点下存在next[ind]，直接下移即可。</p>
<p>那如果我们直接把找不到的next[ind]直接赋值为最终它等价关系下的next[ind]，因为如果不存在，那本来next[ind]也是空的，为什么不利用起来。那么上面的while循环可以直接省略,可以直接取。</p>
<p>即build_AC的时候：</p>
<p>原先如果当前结点下不存在next[i]我们直接跳过。现在修改为当前结点的next[i]直接等于当前结点的fail指针下的next[i]。</p>
<p>这里不用循环，因为fail指针也是用同样的方法初始化了所有的next[i]，无论是存在还是最终不存在指向root，都可以按层序进行构建。</p>
<p>需要修改的三个地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_AC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    root-&gt;fail = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(root-&gt;next[i]);</span><br><span class="line">            root-&gt;next[i]-&gt;fail = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一处，对于第一层结点，如果不存在那么fail指针就是root。</span></span><br><span class="line">            root-&gt;next[i] = root; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;next[i]) &#123;</span><br><span class="line">                <span class="comment">// 如果不存在直接把等价关系存过来</span></span><br><span class="line">                t-&gt;next[i] = t-&gt;fail-&gt;next[i];  </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node *p = t-&gt;fail;</span><br><span class="line">            <span class="comment">/*原先的这一段就可以删掉了</span></span><br><span class="line"><span class="comment">            while (p) &#123;</span></span><br><span class="line"><span class="comment">                if (p-&gt;next[i]) &#123;</span></span><br><span class="line"><span class="comment">                    t-&gt;next[i]-&gt;fail = p-&gt;next[i];</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                p = p-&gt;fail;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (!p) &#123;</span></span><br><span class="line"><span class="comment">                t-&gt;next[i]-&gt;fail = root;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">             <span class="comment">// 因为所有入队过的结点都按上述方法记录了，即使p没有next[i], p的next[i]也被它的父节点赋值过了。</span></span><br><span class="line">            t-&gt;next[i]-&gt;fail = p-&gt;next[i]; </span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;build end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">/* 这一段也可以不用了</span></span><br><span class="line"><span class="comment">        while (p &amp;&amp; p-&gt;next[ind] == nullptr) &#123;</span></span><br><span class="line"><span class="comment">            p = p-&gt;fail;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (p) &#123;</span></span><br><span class="line"><span class="comment">            // 这里别搞错了，记得下移</span></span><br><span class="line"><span class="comment">            Node *t = p-&gt;next[ind];</span></span><br><span class="line"><span class="comment">            p = p-&gt;next[ind];</span></span><br><span class="line"><span class="comment">            while (t) &#123;</span></span><br><span class="line"><span class="comment">                if (t-&gt;flag) &#123;</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; t-&gt;s &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                t = t-&gt;fail;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            p = root;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p = p-&gt;next[ind];  <span class="comment">//直接改成这一句</span></span><br><span class="line">        Node *t = p;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">           <span class="keyword">if</span> (t-&gt;flag) &#123;</span><br><span class="line">               cout &lt;&lt; t-&gt;s &lt;&lt; endl;</span><br><span class="line">           &#125;</span><br><span class="line">           t = t-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div>
          <nav class="post-nav">
    
    <a class="post-nav-item post-nav-prev" href="/2021/10/21/Unicode-and-UTF-8/">
      <div class="nav-arrow">&lt;&nbsp;NEWER</div>
      <span class="post-title">Unicode and UTF-8</span>
    </a>
    
    
    <a class="post-nav-item post-nav-next" href="/2021/10/20/%E5%A0%86/">
      <div class="nav-arrow">OLDER&nbsp;&gt;</div>
      <span class="post-title">堆</span>
    </a>
    
  </nav>

   </main>
</div>

  <footer class="footer">
    <small class="footer_copyright">
      <div id="bottom-inner">
        © 2021 Site by ooxoio using
        <a target="_blank" rel="noopener" href="http://hexo.io">hexo blog framework</a>.
        <br>
        <p> Theme is <a target="_blank" rel="noopener" href="https://github.com/dewjohn/hexo-theme-klise">Klise</a></p>
      </div>
    </small>
  </footer>
  
  

    
      <script src="/js/main.js"></script>
    
  
  <script>
    window.FPConfig = {
      delay: 0,
      ignoreKeywords: [],
      maxRPS: 3,
      hoverDelay: 50,
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>
</body>
</html>
